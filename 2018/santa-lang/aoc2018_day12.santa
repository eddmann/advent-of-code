input: read("aoc://2018/12")

let sum = reduce(+, 0);

let parse_notes = |input| {
  let [initial, _, ..patterns] = lines(input);

  let pots = zip(0.., initial[15..]) |> reduce(
    |initial, [position, pot]| if pot == "#" { initial + {position} } else { initial },
    {}
  );

  return [
    pots,
    patterns |> map(split(" => ")) |> hash
  ];
}

let generation = |patterns, pots| {
  min(pots)-2..max(pots)+2 |> reduce(
    |next, position| {
      let pattern = -2..2
        |> map(|offset| if pots `contains` (position + offset) { "#" } else { "." })
        |> reduce(+, "");

      if patterns[pattern] == "#" { next + {position} } else { next };
    },
    {}
  );
}

part_one: {
  let [initial, patterns] = parse_notes(input);

  1..20
    |> reduce(generation(patterns), initial)
    |> sum;
}

part_two: {
  let [initial, patterns] = parse_notes(input);

  let mut previous = initial;
  let mut duplicate_diff = 0;
  let mut duplicate_cycle = 0;

  0.. |> each |cycle| {
    let next = generation(patterns, previous);

    if sum(next) - sum(previous) == duplicate_diff {
      duplicate_cycle = cycle;
      break;
    }

    duplicate_diff = sum(next) - sum(previous);
    previous = next;
  }

  return (50000000000 - duplicate_cycle) * duplicate_diff + sum(previous);
}

test: {
  input: "initial state: #..#.#..##......###...###

...## => #
..#.. => #
.#... => #
.#.#. => #
.#.## => #
.##.. => #
.#### => #
#.#.# => #
#.### => #
##.#. => #
##.## => #
###.. => #
###.# => #
####. => #"
  part_one: 325
}
